package org.homs.lechuga.entity;

import org.homs.lechuga.entity.generator.GenerateOn;
import org.homs.lechuga.entity.query.QueryProcessor;
import org.homs.lechuga.entity.reflect.ReflectUtils;
import org.homs.lechuga.exception.LechugaException;
import org.homs.lentejajdbc.DataAccesFacade;
import org.homs.lentejajdbc.Mapable;
import org.homs.lentejajdbc.ScalarMappers;
import org.homs.lentejajdbc.exception.EmptyResultException;
import org.homs.lentejajdbc.exception.TooManyResultsException;
import org.homs.lentejajdbc.query.QueryObject;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;

public class EntityManager<E, ID> {

    final EntityModel<E> entityModel;
    final DataAccesFacade facade;

    final EntityManagerSqlOperations entityManagerSqlOperations;
    final Mapable<E> rowMapper;

    public EntityManager(EntityModel<E> entityModel, DataAccesFacade facade) {
        this.entityModel = entityModel;
        this.facade = facade;

        this.entityManagerSqlOperations = new EntityManagerSqlOperations(entityModel);
        this.rowMapper = rs -> {
            E entity = ReflectUtils.newInstance(entityModel.getEntityClass());
            for (EntityPropertyModel p : entityModel.getAllProperties()) {
                Object value = p.getColumnHandler().readValue(rs, p.getColumnName());
                p.setValue(entity, value);
            }
            return entity;
        };
    }

    public EntityModel<E> getEntityModel() {
        return entityModel;
    }

    public Mapable<E> getRowMapper() {
        return rowMapper;
    }

    public E loadById(ID idValue) throws EmptyResultException, TooManyResultsException {
        QueryObject q = entityManagerSqlOperations.queryForLoadById(idValue);
        try {
            return facade.loadUnique(q, getRowMapper());
        } catch (TooManyResultsException e) {
            throw new LechugaException("unique result expected, but obtained many: " + q.toString(), e);
        }
    }

    public List<E> loadByIds(Iterable<ID> ids) throws EmptyResultException, TooManyResultsException {
        List<E> r = new ArrayList<>();
        for (ID id : ids) {
            r.add(loadById(id));
        }
        return r;
    }

    public QueryProcessor<E> createQuery(String selfAlias) {
        return new QueryProcessor<>(facade, getRowMapper()).addAlias(selfAlias, this);
    }

    public List<E> loadAll(Order... orders) {
        QueryObject q = entityManagerSqlOperations.queryForLoadAll(orders);
        return facade.load(q, getRowMapper());
    }

    public List<E> loadByProperty(String propertyName, Object value, Order... orders) {
        QueryObject q = entityManagerSqlOperations.queryForLoadByProp(propertyName, value, orders);
        return facade.load(q, getRowMapper());
    }

    public void deleteById(ID idValue) {
        QueryObject q = entityManagerSqlOperations.queryForDeleteById(idValue);
        int affectedResults = facade.update(q);
        if (affectedResults != 1) {
            throw new LechugaException(
                    "DELETE: " + q.toString() + ": expected affectedRows=1, but affected: " + affectedResults);
        }
    }

    public void delete(E entity) {
        QueryObject q = entityManagerSqlOperations.queryForDelete(entity);
        int affectedResults = facade.update(q);
        if (affectedResults != 1) {
            throw new LechugaException(
                    "DELETE: " + q.toString() + ": expected affectedRows=1, but affected: " + affectedResults);
        }
    }

    /**
     * fa un {@link #insert(Object)} o un {@link #update(Object)}, segons convingui.
     *
     * <pre>
     * si almenys una PK és Autogen:
     *         insert: totes les PK han d'estar informades, menys les Autogen.
     *         update: totes les PK han d'estar informades.
     * sino
     *         si almenys una PK està a null =&gt; error
     *
     *         si exist()
     *             update()
     *         sino
     *             insert()
     *         fisi
     * fisi
     * </pre>
     */
    public void store(final E entity) {

        Collection<EntityPropertyModel> autogens = entityModel.getAutogeneratedProperties();
        boolean algunaIdAutogen = !autogens.isEmpty();

        for (EntityPropertyModel p : autogens) {
            /**
             * si una propietat @Id és primitiva, el seu valor mai serà null (p.ex. serà 0)
             * i l'store() no funcionarà. Si es té una @Id primitiva, usar insert()/update()
             * en comptes d'store().
             */
            if (p.getPropertyType().isPrimitive()) {
                throw new LechugaException(
                        "@Id-annotated field is of primitive type: use insert()/update() instead of store(): "
                                + entity.getClass().getSimpleName() + "#" + p.getPropertiesPath());
            }
        }

        if (algunaIdAutogen) {

            boolean insert = false;
            for (EntityPropertyModel p : entityModel.getIdProperties()) {
                Object value = p.getValue(entity);
                if (p.getGenerator() == null) {
                    if (value == null) {
                        throw new LechugaException("una propietat PK no-autogenerada té valor null en store(): "
                                + entity.getClass().getSimpleName() + "#" + p.getPropertiesPath());
                    }
                } else {
                    if (value == null) {
                        insert = true;
                    }
                }
            }

            if (insert) {
                insert(entity);
            } else {
                update(entity);
            }

        } else {

            for (EntityPropertyModel p : entityModel.getIdProperties()) {
                Object value = p.getValue(entity);
                if (value == null) {
                    throw new LechugaException("una propietat PK no-autogenerada té valor null en store(): "
                            + entity.getClass().getSimpleName() + "#" + p.getPropertiesPath());
                }
            }

            boolean update = exists(entity);
            if (update) {
                update(entity);
            } else {
                insert(entity);
            }
        }
    }

    public boolean exists(final E entity) {
        QueryObject q = entityManagerSqlOperations.queryForExists(entity);
        try {
            long count = facade.loadUnique(q, ScalarMappers.LONG);
            return count > 0L;
        } catch (EmptyResultException e) {
            throw new LechugaException("EXISTS: " + q.toString(), e);
        } catch (TooManyResultsException e) {
            throw new LechugaException("duplicated entity found with the same PK? " + entity + " => " + q, e);
        }
    }

    public boolean existsById(final ID id) {
        QueryObject q = entityManagerSqlOperations.queryForExistsById(id);
        try {
            long count = facade.loadUnique(q, ScalarMappers.LONG);
            return count > 0L;
        } catch (EmptyResultException e) {
            throw new LechugaException("EXISTS: " + q.toString(), e);
        } catch (TooManyResultsException e) {
            throw new LechugaException("duplicated entity found with the same PK? " + id + " => " + q, e);
        }
    }

    // https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html

    public void update(E entity) {
        QueryObject q = entityManagerSqlOperations.queryForUpdate(entity);
        int affectedResults = facade.update(q);

        if (affectedResults != 1) {
            throw new LechugaException(
                    "UPDATE: " + q.toString() + ": expected affectedRows=1, but affected: " + affectedResults);
        }
    }

    public void insert(E entity) {

        generateBeforeInsert(facade, entity);

        QueryObject q = entityManagerSqlOperations.queryForInsert(entity);
        facade.update(q);

        generateAfterInsert(facade, entity);
    }

    protected void generateBeforeInsert(DataAccesFacade facade, E entity) {
        for (var p : entityModel.getAutogeneratedProperties()) {
            if (p.getGenerator().getGenerateOn() == GenerateOn.BEFORE) {
                var query = p.getGenerator().getQuery();
                Object generatedValue = facade.loadUnique(query, ScalarMappers.getScalarMapperFor(p.getPropertyType()));
                p.setValue(entity, generatedValue);
            }
        }
    }

    protected void generateAfterInsert(DataAccesFacade facade, E entity) {
        for (var p : entityModel.getAutogeneratedProperties()) {
            if (p.getGenerator().getGenerateOn() == GenerateOn.AFTER) {
                var query = p.getGenerator().getQuery();
                Object generatedValue = facade.loadUnique(query, ScalarMappers.getScalarMapperFor(p.getPropertyType()));
                p.setValue(entity, generatedValue);
            }
        }
    }

    public void storeAll(E... entities) {
        storeAll(Arrays.asList(entities));
    }

    public void storeAll(Iterable<E> entities) {
        for (var entity : entities) {
            store(entity);
        }
    }
}
